# -*- coding: utf-8 -*-
"""
Created on Wed Jun  7 15:14:59 2017

@author: nguarinz
"""
from __future__ import division, print_function
import numpy as np
from scipy.special import eval_hermite, roots_hermite, factorial, lambertw
from scipy.linalg import eigh


def gauss_hermite(fun, n, args=None):
    xi, wi = roots_hermite(n)
    return np.sum(fun(xi, *args) * wi)


def hermite_mag(n):
    return np.sqrt(np.pi**0.5 * 2**n * factorial(n))


def hermite_norm(n, x):
    return eval_hermite(n, x)/ hermite_mag(n)


def delta(m, n):
    """Kronecker delta"""
    if m == n:
        val = 1
    else:
        val = 0
    return val


def alpha(m, n):
    """Integral of x * psi_m * psi_n
    
    psi_m are the Hermite functions
    """
    val = 0
    if m == n + 1:
        val = np.sqrt((n + 1)/2)
    elif m == n - 1:
        val = np.sqrt(n/2)
    return val


def beta(m, n):
    """Integral of x**2 * psi_m * psi_n
    
    psi_m are the Hermite functions
    """
    val = 0
    if m == n - 2:
        val = np.sqrt(n*(n - 1))/2
    elif m == n:
        val = (2*n + 1)/2
    elif m == n + 2:
        val = np.sqrt((n + 1)*(n + 2))/2
    return val


def potential_integrand(x, m, n, potential):
    return hermite_norm(m, x) * hermite_norm(n, x) * potential(x)


def hamiltonian_mat(num, potential, ngpts):
    """Compute the Hamiltonian for a given potential
    
    The potential integral is computed using ngpts Gauss points and the
    Hermite-Gauss quadrature scheme.
    
    Parameters
    ----------
    num : int
        Number of basis functions to use.
    potential : callable
        Potential function.
    ngpts : int
        Number of Gauss-Hermite points to use for the integral
        of the potential contribution to the Hamiltonian.
    
    Returns
    -------
    Hmat : ``(num, num)`` ndarray
        Discretized version of the Hamiltonian corresponding
        to the subspace generated by the span of the basis
        functions.
    """
    Hmat = np.zeros((num, num))
    for row in range(0, num):
        for col in range(0, num):
            fac_row = hermite_mag(row - 1)/hermite_mag(row)
            fac_col = hermite_mag(col - 1)/hermite_mag(col)
            kin = 4*row*col*delta(row, col)*fac_row**2 -\
                  2*row*alpha(row - 1, col)*fac_row -\
                  2*col*alpha(row, col - 1)*fac_col +\
                  beta(row, col)
            pot = gauss_hermite(potential_integrand, ngpts,
                                      args=(row, col, potential))
            Hmat[row, col] = 0.5*kin + pot
    return Hmat


nterms = 100
ngpts = 100
potential = lambda x: 0.5*np.sin(x)**2 * x**2
Hmat = hamiltonian_mat(nterms, potential, ngpts)
vals, vecs = eigh(Hmat)
print(np.round(vals[:6], 6))


#%% Plotting
import matplotlib.pyplot as plt
x = np.linspace(-10, 10, 2001)
for k in range(4):
    vec = 0
    for j in range(nterms):
        coeff = vecs[j, k]
        vec += coeff * hermite_norm(j, x) * np.exp(-x**2/2)
    plt.plot(x, vec, label=r"$n=%i$"%k)

plt.xlabel(r"$x$")
plt.ylabel(r"$\psi(x)$")
plt.legend()    
plt.show()
